\section{Introduction}
In model-driven software engineering, the intensive use of generative programming techniques has become a common practice for software development since it reduces the development and maintenance effort by developing at a higher-level of abstraction through the use of domain-specific languages~\cite{brambilla2012model} (DSLs). 
DSLs, as opposed to general-purpose languages, are software languages that focus on specific problem domains. Thus, the realization of model-driven software development for a specific domain requires the creation of effective code generators and compilers for these DSLs.
The use of code generators is needed to transform manually designed models to software artifacts, which can be deployed on different target platforms. This can clearly reduce the effort of software implementation. A code generator is able to translate source code programs represented in a graphical modeling language (model) into general purpose programming languages such as C, Java, C++, etc. In turn, generated code is transformed into machine code (binaries) using a set of specific compilers.
These compilers serve as a basis to target different ranges of platforms. 
%Many technologies, such as Docker containers, provide new opportunities to automate the deployment of produced code into a distributed and heterogeneous component-based infrastructure

In fact, during the code generation process, different optimizations may be applied for code transformation. Improvement of source program can refer to several different characteristics of the produced code such execution time, memory consumption, code size, among others~\cite{almagor2004finding,pan2006fast}.
For example, embedded systems for which code is generated often have limited resources. 
Therefore, optimization techniques must be applied whenever possible to generate efficient code with respect to available resources\cite{nagiub2013automatic}. 
As general-purpose optimizations, compiler creators\footnote{We consider compilers as a kind of code generator in this paper.} usually define fixed and program-independent sequence optimizations.
For example, in GCC, we can distinguish optimization levels from O1 to O3. Each optimization level involves a fixed list of compiler optimization options. 
However, industrial code generators may have a huge number of potential optimization combinations, making it hard and time-consuming for software developers to find the sequence of optimizations that satisfies user key objectives. 

In this paper we explore the relationship between runtime execution of optimized code and non-functional properties.
We propose a component-based tooled approach to check code generators non-functional properties through the monitoring of generated code in a controlled sandboxing environment. 
Our approach is based on microservices to automate the deployment and monitoring of different variants of optimized code into a distributed and heterogeneous component-based infrastructure. 
We assess the effectiveness of our approach by evaluating the optimizations performed by the GCC compiler, a widely used compiler in software engineering community. 
We also present a number of case studies, in which the tool was successfully used.
%This to ensure the efficiency of generated code, deployed components must be checked and verified regarding their non-functional behavior
%\footnote{\url{https://www.docker.com}} 

The primary contribution of this paper can be summarized as follows: 
(1) We propose a microservice infrastructure to ensure the deployment and monitoring of generated code regarding resource consumption; 
(2) We evaluate the effectiveness of our approach by testing the GCC compiler optimizations across two case studies.
 

The paper is organized as follows.
Section 2 describes the motivation behind this work. A search-based technique for compiler optimizations exploration is presented in Section 3. 
We present in Section 4 our infrastructure for non-functional testing using microservices. 
The evaluation and results of our experiments across two case studies are discussed in Section 5. 
Finally, concluding remarks and future work are provided in Section 6.


%The difference between classical compilers like GCC, LLVM and code generators is that code generators are used only by few people comparing to famous compilers like GCC. Moreover, code generators face a high rate of changes and update versions due to new development needs. Hence, it becomes necessary to check the quality of produced code. This will help software maintainers to verify the correct functioning of code generators.  Among the most important properties to check, we distinguish the non functional properties.

%Like traditional compilers, code generators typically perform multiple passes over various intermediate forms during code transformation. Many rules may also be applied and that differs from one generator to another. These passes are complex and highly dependent on target platform architecture. 

 
 

  % \section{Motivations}
 %\section{Previous work}
%\section{Approach Overview}
